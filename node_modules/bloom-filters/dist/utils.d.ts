/// <reference types="node" />
/**
 * Utilitaries functions
 * @namespace Utils
 * @private
 */
/**
 * @typedef {TwoHashes} Two hashes of the same value, as computed by {@link hashTwice}.
 * @property {number} first - The result of the first hashing function applied to a value
 * @property {number} second - The result of the second hashing function applied to a value
 * @memberof Utils
 */
export interface TwoHashes {
    first: number;
    second: number;
}
export declare type HashableInput = string | ArrayBuffer | Buffer;
/**
 * Create a new array fill with a base value
 * @param size - The size of the array
 * @param defaultValue - The default value used to fill the array. If it's a function, it will be invoked to get the default value.
 * @return A newly allocated array
 * @memberof Utils
 */
export declare function allocateArray<T>(size: number, defaultValue: T | (() => T)): Array<T>;
/**
 * (64-bits only) Hash a value into two values (in hex or integer format)
 * @param  value - The value to hash
 * @param  asInt - (optional) If True, the values will be returned as an integer. Otherwise, as hexadecimal values.
 * @param seed the seed used for hashing
 * @return The results of the hash functions applied to the value (in hex or integer)
 * @memberof Utils
 * @author Arnaud Grall & Thomas Minier
 */
export declare function hashTwice(value: HashableInput, asInt?: boolean, seed?: number): TwoHashes;
export declare function hashTwiceAsString(value: HashableInput, seed?: number): {
    first: string;
    second: string;
};
/**
 * (64-bits only) Same as hashTwice but return Numbers and String equivalent
 * @param  val the value to hash
 * @param  seed the seed to change when hashing
 * @return A object of shape {int: {first: <number>, second: <number>}, string: {first: <hex-string>, second: <hex-string>}
 * @author Arnaud Grall
 */
export declare function allInOneHashTwice(val: HashableInput, seed?: number): {
    int: {
        first: number;
        second: number;
    };
    string: {
        first: string;
        second: string;
    };
};
/**
 * Apply Double Hashing to produce a n-hash
 *
 * This implementation used directly the value produced by the two hash functions instead of the functions themselves.
 * @see {@link http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=4060353E67A356EF9528D2C57C064F5A?doi=10.1.1.152.579&rep=rep1&type=pdf} for more details about double hashing.
 * @param  n - The indice of the hash function we want to produce
 * @param  hashA - The result of the first hash function applied to a value.
 * @param  hashB - The result of the second hash function applied to a value.
 * @param  size - The size of the datastructures associated to the hash context (ex: the size of a Bloom Filter)
 * @return The result of hash_n applied to a value.
 * @memberof Utils
 * @author Thomas Minier
 */
export declare function doubleHashing(n: number, hashA: number, hashB: number, size: number): number;
/**
 * Generate a set of distinct indexes on interval [0, size) using the double hashing technique
 * @param  element  - The element to hash
 * @param  size     - the range on which we can generate an index [0, size) = size
 * @param  number   - The number of indexes desired
 * @param  seed     - The seed used
 * @return A array of indexes
 * @author Arnaud Grall
 */
export declare function getDistinctIndices(element: HashableInput, size: number, number: number, seed?: number): Array<number>;
/**
 * Generate hashCount indexes, one index per [0, size)
 * it uses the double hashing technique to generate the indexes
 * @param  element    - The element to hash
 * @param  size       - The range on which we can g-enerate the index, exclusive
 * @param  hashCount  - The number of indexes we want
 * @return An array of indexes
 */
export declare function getIndices(element: HashableInput, size: number, hashCount: number, seed?: number): Array<number>;
/**
 * Generate a random int bewteen two bounds (included)
 * @param min - The lower bound
 * @param max - The upper bound
 * @param random - Function used to generate random floats
 * @return A random int bewteen lower and upper bound (included)
 * @memberof Utils
 * @author Thomas Minier
 */
export declare function randomInt(min: number, max: number, random?: () => number): number;
/**
 * Return the non-destructive XOR of two buffers
 * @param a - The buffer to copy, then to xor with b
 * @param b - The buffer to xor with
 * @return The results of the XOR between the two buffers
 * @author Arnaud Grall
 */
export declare function xorBuffer(a: Buffer, b: Buffer): Buffer;
/**
 * Return true if the buffer is empty, i.e., all value are equals to 0.
 * @param  buffer - The buffer to inspect
 * @return True if the buffer only contains zero, False otherwise
 * @author Arnaud Grall
 */
export declare function isEmptyBuffer(buffer: Buffer | null): boolean;
/**
 * Hash an item as an unsigned int
 * @param  elem - Element to hash
 * @param  seed - The hash seed. If its is UINT32 make sure to set the length to 32
 * @param  length - The length of hashes (defaults to 64 bits)
 * @return The hash value as an unsigned int
 * @author Arnaud Grall
 */
export declare function hashAsInt(elem: HashableInput, seed?: number, length?: number): number;
/**
 * Hash an item as a string
 * @param  elem - Element to hash
 * @param  seed - The hash seed. If its is UINT32 make sure to set the length to 32
 * @param  base - The base in which the string will be returned, default: 16
 * @param  length - The length of hashes (defaults to 64 bits)
 * @return The hashed value as a string
 * @author Arnaud Grall
 */
export declare function hashAsString(elem: HashableInput, seed?: number, base?: number, length?: number): string;
/**
 * Hash an item as a string
 * @param  elem - Element to hash
 * @param  seed - The hash seed. If its is UINT32 make sure to set the length to 32
 * @param  base - The base in which the string will be returned, default: 16
 * @param  length - The length of hashes (defaults to 64 bits)
 * @return The item hased as an int and a string
 * @author Arnaud Grall
 */
export declare function hashIntAndString(elem: HashableInput, seed?: number, base?: number, length?: number): {
    int: number;
    string: string;
};
/**
 * Return the default seed used in the package
 * @return A ssed as a floating point number
 * @author Arnaud Grall
 */
export declare function getDefaultSeed(): number;
/**
 * Return the next power of 2 of x
 * @param  x - Value
 * @return The next power of 2 of x
 */
export declare function power2(x: number): number;
/**
 * Convert an hex string into a binary string
 * @param  hex  - A base 16 string
 * @return A base 2 string
 */
export declare function hex2bin(hex: string): string;
